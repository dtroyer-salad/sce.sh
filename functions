#!/bin/bash
# functions - Common shell functions
# SPDX-License-Identifier: MIT
# Copyright 2021 Dean Troyer

# Ensure this is not sourced multiple times
[[ -z "$_SCE_FUNCTIONS" ]] || return 0
declare -r _SCE_FUNCTIONS=1

FUNC_DIR=$(cd $(dirname "${BASH_SOURCE:-$0}") && pwd)

# Optional Global Config Variables
# SCE_LOG_FILE - log everything to file if set
# SCE_VERBOSE - emit reposync script logging to stdout
# SCE_DRY_RUN - do not execute RT API commands
# SCE_VERBOSE - emit RT API commands

# Set the SCE Public API endpoint if it not already set
SCE_URL=${SCE_URL:-https://api.salad.com/api/public}

# Set the API token if it is readable and is not already set
[[ -r $HOME/.sce-apikey ]] && SCE_APIKEY=${SCE_APIKEY:-$(head -1 $HOME/.sce-apikey)}

# Save trace setting
_XTRACE_FUNCTIONS=$(set +o | grep xtrace)
set +o xtrace


# Logging Functions
# =================

# Format messages for the log file
# Always outputs message to stdout, stderr or log file
# _log level message
_log() {
    local level=$1; shift
    local msg="$(date --rfc-3339 seconds | tr ' ' 'T') $level ${BASH_SOURCE[2]}: $@"

    if [[ -z $SCE_LOG_FILE ]]; then
        if [[ "$level" == "ERROR" ]]; then
            echo "$msg" >&2
        else
            echo "$msg"
        fi
    else
        echo "$msg" >> $SCE_LOG_FILE
    fi
}

# Prints line number and "message" then exits
# die $LINENO "message"
function die {
    local exitcode=$?
    set +o xtrace
    local line=$1; shift
    if [ $exitcode == 0 ]; then
        exitcode=1
    fi
    err $line "$*"
    # Give buffers a second to flush
    sleep 1
    exit $exitcode
}

# Format ERROR messages for the log file or stderr
# Preserves error code and xtrace status
# err "message"
function err {
    local exitcode=$?
    local xtrace
    xtrace=$(set +o | grep xtrace)
    set +o xtrace

    _log "ERROR" "$*"

    $xtrace
    return $exitcode
}

# Format INFO messages for the log file
# Only outputs message if SCE_VERBOSE is set
# Preserves error code and xtrace status
# info message
function info {
    local exitcode=$?
    local xtrace
    xtrace=$(set +o | grep xtrace)
    set +o xtrace

    [[ -n $SCE_VERBOSE ]] && _log "INFO" "$*"

    $xtrace
    return $exitcode
}

# Format messages for the log file
# Always outputs message to stdout, stderr or log file
# Preserves error code and xtrace status
# log message
function log {
    local exitcode=$?
    local xtrace
    xtrace=$(set +o | grep xtrace)
    set +o xtrace

    _log "" "$*"

    $xtrace
    return $exitcode
}


# REST Functions
# ==============

_curl="curl --silent "
_j_curl="$_curl --header 'accept: application/json' --header 'content-type: application/json' "

# Authenticated cURL: Include API token header only if it is set and not --dry-run
_a_curl=$_j_curl
[[ -z $SCE_DRY_RUN ]] && _a_curl="$_j_curl ${SCE_APIKEY:+-H Salad-Api-Key:$SCE_APIKEY} "

# DELETE <url>
function DELETE {
    local _dry_run
    local _url=${1}
    shift

    [[ -n $SCE_DRY_RUN ]] && _dry_run=echo
    [[ -n $SCE_VERBOSE ]] && echo "$_curl -X DELETE $_url" >&2

    $_dry_run $_a_curl -X DELETE $_url
    local _x=$?; [[ $_x == 0 ]] || die $LINENO "cURL exit $_x"
}

# GET <url>
function GET {
    local _dry_run
    local _url=${1}
    shift

    [[ -n $SCE_DRY_RUN ]] && _dry_run=echo
    [[ -n $SCE_VERBOSE ]] && echo "$_curl -X GET $_url" >&2

    $_dry_run $_a_curl -X GET $_url
    local _x=$?; [[ $_x == 0 ]] || die $LINENO "cURL exit $_x"
}

# POST <url> [...]
function POST {
    local _dry_run
    local _url=${1}
    shift

    [[ -n $SCE_DRY_RUN ]] && _dry_run=echo
    [[ -n $SCE_VERBOSE ]] && echo "$_curl -X POST $_url $@" >&2

    $_dry_run $_a_curl -X POST $_url $@
    local _x=$?; [[ $_x == 0 ]] || die $LINENO "cURL exit $_x"
}

# PUT <url>
function PUT {
    local _dry_run
    local _url=${1}
    shift

    [[ -n $SCE_DRY_RUN ]] && _dry_run=echo
    [[ -n $SCE_VERBOSE ]] && echo "$_curl -X PUT $_url" >&2

    $_dry_run $_a_curl -X PUT $_url
    local _x=$?; [[ $_x == 0 ]] || die $LINENO "cURL exit $_x"
}


# rt_delete <rt-path>
# Delete Item: https://www.jfrog.com/confluence/display/rtf/artifactory+rest+api#ArtifactoryRESTAPI-DeleteItem
function rt_delete {
    DELETE "$SCE_URL/${1}"
}

# Check if artifact exists, returns HTTP code, 404 if not found
function rt_exists {
    local info=$(GET $SCE_URL/api/storage/$1)
    local status=$(echo $info | jq '.errors[0].status')
    return $status
}

# rt_list <rt-path> [deep]
# File List: https://www.jfrog.com/confluence/display/rtf/artifactory+rest+api#ArtifactoryRESTAPI-FileList
function rt_list {
    local _deep
    [[ -n $2 ]] && _deep="?list&deep=1&mdtimestamps=1"
    GET "$SCE_URL/api/storage/${1}${_deep}"
}

# rt_list_repos [<repo-type>]
# Get Repositories: https://www.jfrog.com/confluence/display/rtf/artifactory+rest+api#ArtifactoryRESTAPI-GetRepositories
function rt_list_repos {
    local _rt_type
    [[ -n $1 ]] && _rt_type="?type=${1}"
    GET "$SCE_URL/api/repositories${_rt_type}"
}

# rt_mkdir <rt-path>
# Create Directory: https://www.jfrog.com/confluence/display/rtf/artifactory+rest+api#ArtifactoryRESTAPI-CreateDirectory
function rt_mkdir {
    # Ensure path ends in exactly one slash ('/')
    PUT "$SCE_URL/${1%/}/"
}

# rt_move <rt-path> <rt-path>
# Copy Item: https://www.jfrog.com/confluence/display/rtf/artifactory+rest+api#ArtifactoryRESTAPI-MoveItem
function rt_move {
    local _dry
    [[ -n $SCE_DRY_RUN ]] && _dry="&dry=1"
    POST "$SCE_URL/api/move/${1}?to=/${2}${_dry}"
}

# rt_trace <path>
# Trace Artifact Retrieval: https://www.jfrog.com/confluence/display/rtf/artifactory+rest+api#ArtifactoryRESTAPI-TraceArtifactRetrieval
function rt_trace {
    GET "$SCE_URL/${1}?trace"
}

# rt_upload_archive <src-dir> <rt-path>
# Upload a directory as an archive file to Artifactory
# Deploy Artifact from Archive: https://www.jfrog.com/confluence/display/rtf/artifactory+rest+api#ArtifactoryRESTAPI-DeployArtifactsfromArchive
function rt_upload_archive {
    local _src=${1}
    local _rt_path=${2}
    local _url=$SCE_URL/${_rt_path}
    local _dry_run

    [[ -n $SCE_DRY_RUN ]] && _dry_run=echo

    $_dry_run $_a_curl -X PUT -i -H "X-Explode-Archive:true" -H "X-Explode-Archive-Atomic:true" -T ${_src} ${_url}
    local _x=$?; [[ $_x == 0 ]] || die $LINENO "cURL exit $_x"
}


# Misc Functions
# ==============

# Normalize many variations of boolean True and False
function trueorfalse {
    local default=$1

    if [[ -z $2 ]]; then
        die $LINENO "variable required for second arg"
    fi

    local testval=${!2:-}
    case "$testval" in
        "1" | [yY]es | "YES" | [tT]rue | "TRUE" ) echo "True" ;;
        "0" | [nN]o | "NO" | [fF]alse | "FALSE" ) echo "False" ;;
        * )                                       echo "$default" ;;
    esac
}

# Restore xtrace
$_XTRACE_FUNCTIONS
